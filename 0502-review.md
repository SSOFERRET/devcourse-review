# :fire: 05/02 학습 내용

## :one: 함수포인터

- 함수명 앞에 *를 붙여주면 함수 포인터가 선언된다.
- 함수 포인터도 포인터이므로 주소값을 저장한다.

```
//자료형(*함수 표인터 이름)(인자 목록)

int (*func)(int a);
```

![1](https://github.com/SSOFERRET/devcourse-review/assets/148465774/5e59fb3e-91ef-46c6-affa-5ddae90a4fef)

- 함수 포인터의 사용 이유
  - 메모리 크기 및 위치가 결정되는 시점은 컴파일 타임 또는 런타임시점이다.
    - 컴파일 타임 시점: 정적 바인딩
    - 런타임 시점: 동적 바인딩
  - 함수 포인터의 사용은 프로그램의 유연한 확장성을 제공한다.
  - 예) VS code extension는 플러그인 방식으로 동작하는데, 이는 변경 사항 생길 때마다 매번 컴파일해야할 필요가 없다.
    
---

## :two: 구조체

- 하나 이상의 서로 다른 종류의 변수를 묶어서 새로운 데이터 타입을 정의하는 것.
- 추상적이다.

- 사용 이유: 연관된 변수를 하나로 묶어서 관리함으로써 데이터 관리에 유용하다.
- 기본 형태
```c
struct student {
  char name[10];
  int age;
  int height;
};
```

- 접근하려면 직접 접근자(.)를 통하면 된다.
```
#include <stdio.h>
#include <string.h>

struct student{
    char name[10];
    int age;
    int height;
}st1;

int main()
{
    strcpy(st1.name, "이창현");
    st1.age = 20;
    st1.height = 178;
    
    printf("이름: %s, 나이: %d, 키: %d\n", st1.name, st1.age, st1.height);
}
```

❔ **평가 문제 >>** 우체국 택배 물건의 종류, 무게, 높이 정보를 가지고 있는 구조체를 선언한 후, 구조체 멤버 값을 사용자로부터 입력 받은 후 출력하는 프로그램 작성하라.
```c
#include <stdio.h>
#include <string.h>

struct object{
    char name[20];
    int height;
    int weight;
}obj;

int main(){
    scanf("%s", obj.name);
    scanf("%d", &obj.height);
    scanf("%d", &obj.weight);
    
    printf("물품명: %s\n물품 높이: %dcm\n물품 무게: %dkg\n", obj.name, obj.height, obj.weight);
}

/**
만화책 
20
10
물품명: 만화책
물품 높이: 20cm
물품 무게: 10kg
*/
```

---

## :three: 공용체

- 사용자 정의 자료형
- 구조체와의 차이점은, 구조체는 메모리 공간을 각 멤버마다 따로 사용하는 반면, 공용체는 메모리 공간을 공유한다는 것이다.
```
union unTemp{
  char a;
  int b;
  double c;
}un;
```

---

## :four: 열거형

- 데이터를 열거한 집합. 연속적인 데이터를 취급하는데에 적합하다.
- 컴파일러는 열거형 멤버들을 정수형 상수로 취급한다.
```c
enum Week{
  sun=0,
  mon,
  tue,
  wed,
  thu,
  fri,
  sat
};
```

![3](https://github.com/SSOFERRET/devcourse-review/assets/148465774/8c182ed0-2262-491f-a12f-23dc9f3dd639)

---

## :five: 동적 메모리 할당

- 메모리 영역
  - 코드 영역: 실행할 명령어들이 순서대로 쌓인다. CPU가 하나씩 가져간다.
  - 스택 영역: LIFO. 지역 변수 및 매개 변수 등은 스택 영역을 사용.
  - 힙 영역: 컴퓨터 메모리의 일부가 할당되었다가 회수되는 일이 반복되는 영역. ← 동적 메모리
  - 데이터 영역: 전역변수나 static 변수가 저장되는 메모리 영역. 프로그램 종료 시 소멸.
- 동적 메모리를 할당하는 이유
  - 일반 변수의 메모리 할당은 컴파일 타임에 이루어진다.
  - 유동적인 메모리 크기를 필요로 하는 데이터의 경우 실행 중에 대응하기 위해 동적 메모리 할당 기법을 사용한다.
    
```
void* malloc(size_t size);
// size는 바이트 단위
// 메모리 할당 되면 메모리의 주소값을 리턴한다.
// 메모리 부족 시 NULL 포인터를 리턴한다.
// void*의 의미는 타입이 지정되지 않은 포인터라는 뜻이다.
```

- 사용자가 말록을 통해 요구하는 메모리는 stack 메모리의 포인터 변수를 통해서만 사용이 가능하다.
- 사용한 이후 free를 이용해 꼭 해제해줘야한다. 아닐 경우 메모리 leak이 생긴다.

---

## :six: 객체 지향 프로그래밍 방식

- 이 세상의 모든 사물이라는 개념들을 프로그램화 시키겠다!
- 객체 지향이 나오기 전의 프로그래밍
  - 구조적 프로그래밍: 순차적, 하향식, 폭포수. 기능적인 기본 단위는 함수이다. 수정하기 힘들다.

### 📝 추상화



### 📝 캡슐화

- 은닉하다. 숨긴다.
- 은닉된 데이터와 외부로부터 데이터를 조작할 인터페이스가 한데 묶는 것을 말한다.
